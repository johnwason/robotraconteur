<?xml version="1.0"?>
<doc>
  <assembly>
    <name>RobotRaconteurNET</name>
  </assembly>
  <members>

    <!-- constants -->

    <member name="T:RobotRaconteur.DataTypes">
      <summary>
        Type codes for types supported by Robot Raconteur
      </summary>
      <remarks>
        Data type codes are used in messages and service definition parsers.

        Data is always stored as little-endian, except for UUID which are big endian
      </remarks>
    </member>
    <member name="F:RobotRaconteur.DataTypes.void_t">
      <summary>void or null type</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.double_t">
      <summary>IEEE-754 64-bit floating point number</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.single_t">
      <summary>IEEE-754 32-bit floating point number</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.int8_t">
      <summary>8-bit signed integer</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.uint8_t">
      <summary>8-bit unsigned integer</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.int16_t">
      <summary>16-bit signed integer</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.uint16_t">
      <summary>16-bit unsigned integer</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.int32_t">
      <summary>32-bit signed integer</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.uint32_t">
      <summary>32-bit unsigned integer</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.int64_t">
      <summary>64-bit signed integer</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.uint64_t">
      <summary>64-bit unsigned integer</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.string_t">
      <summary>UTF-8 string</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.cdouble_t">
      <summary>128-bit complex double (real,imag)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.csingle_t">
      <summary>64-bit complex float (real,imag)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.bool_t">
      <summary>8-bit boolean</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.structure_t">
      <summary>structure (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.vector_t">
      <summary>map with int32 key (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.dictionary_t">
      <summary>map with string key (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.object_t">
      <summary>object type (not serializable)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.varvalue_t">
      <summary>varvalue type (not serializable)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.varobject_t">
      <summary>varobject type (not serializable)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.list_t">
      <summary>list type (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.pod_t">
      <summary>pod type (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.pod_array_t">
      <summary>pod array type (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.pod_multidimarray_t">
      <summary>pod multidimarray type (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.enum_t">
      <summary>enum type (not serializable uses int32 for messages)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.namedtype_t">
      <summary>namedtype definition (not serializable)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.namedarray_t">
      <summary>namedarray type (not serializable)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.namedarray_array_t">
      <summary>namedarray array type (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.namedarray_multidimarray_t">
      <summary>namedarray multidimarray type (nested message type)</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes.multidimarray_t">
      <summary>multi-dimensional numeric array (nested message type)</summary>
    </member>


    <member name="T:RobotRaconteur.DataTypes_ArrayTypes">
      <summary>
        Array type enum for TypeDefinition parser class
      </summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes_ArrayTypes.ArrayTypes_none">
      <summary>type is not an array</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes_ArrayTypes.ArrayTypes_array">
      <summary>type is a single dimensional array</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes_ArrayTypes.ArrayTypes_multidimarray">
      <summary>type is a multidimensional array</summary>
    </member>


    <member name="T:RobotRaconteur.DataTypes_ContainerTypes">
      <summary>
        Container type enum for TypeDefinition parser class
      </summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes_ContainerTypes.ContainerTypes_none">
      <summary>type does not have a container</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes_ContainerTypes.ContainerTypes_list">
      <summary>type has a list container</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes_ContainerTypes.ContainerTypes_map_int32">
      <summary>type has a map with int32 keys container</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes_ContainerTypes.ContainerTypes_map_string">
      <summary>type has a map with string keys container</summary>
    </member>
    <member name="F:RobotRaconteur.DataTypes_ContainerTypes.ContainerTypes_generator">
      <summary>type has a generator container. Only valid for use with function generator members</summary>
    </member>

    <member name="T:RobotRaconteur.RobotRaconteurNET">
      <summary>
        Global RobotRaconteurNET functions
      </summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_ROUTING_INFO">
      <summary>Message contains ROUTING_INFO section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_ENDPOINT_INFO">
      <summary>Message contains ENDPOINT_INFO section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_PRIORITY">
      <summary>Message contains PRIORITY section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_UNRELIABLE">
      <summary>Message is unreliable and may be dropped</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_META_INFO">
      <summary>Message contains META_INFO section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_STRING_TABLE">
      <summary>Message contains STRING_TABLE section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_MULTIPLE_ENTRIES">
      <summary>Message contains MULTIPLE_ENTRIES section. If unset, message contains one entry</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_EXTENDED">
      <summary>Message contains EXTENDED section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageFlags_Version2Compat">
      <summary>Message flags for compatibility with Message Format Version 2</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_SERVICE_PATH_STR">
      <summary>MessageEntry contains SERVICE_PATH_STR section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_SERVICE_PATH_CODE">
      <summary>MessageEntry contains SERVICE_PATH_CODE section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_MEMBER_NAME_STR">
      <summary>MessageEntry contains MEMBER_NAME_STR section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_MEMBER_NAME_CODE">
      <summary>MessageEntry contains MEMBER_NAME_CODE section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_REQUEST_ID">
      <summary>MessageEntry contains REQUEST_ID section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_ERROR">
      <summary>MessageEntry contains ERROR section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_META_INFO">
      <summary>MessageEntry contains META_INFO section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_EXTENDED">
      <summary>MessageEntry contains EXTENDED section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageEntryFlags_Version2Compat">
      <summary>MessageEntry flags for compatibility with Message Format Version 2</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageElementFlags_ELEMENT_NAME_STR">
      <summary>MessageElement contains ELEMENT_NAME_STR section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageElementFlags_ELEMENT_NAME_CODE">
      <summary>MessageElement contains ELEMENT_NAME_CODE section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageElementFlags_ELEMENT_NUMBER">
      <summary>MessageElement contains ELEMENT_NUMBER section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageElementFlags_ELEMENT_TYPE_NAME_STR">
      <summary>MessageElement contains ELEMENT_TYPE_NAME_STR section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageElementFlags_ELEMENT_TYPE_NAME_CODE">
      <summary>MessageElement contains ELEMENT_TYPE_NAME_CODE section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageElementFlags_META_INFO">
      <summary>MessageElement contains META_INFO section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageElementFlags_EXTENDED">
      <summary>MessageElement contains EXTENDED section</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.MessageElementFlags_Version2Compat">
      <summary>MessageElement flags for compatibility with Message Format Version 2</summary>
    </member>

    <member name="F:RobotRaconteur.RobotRaconteurNET.RR_VALUE_LIFESPAN_INFINITE">
      <summary>Set wire values to have infinite lifespan and will not expire</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.TranspartCapabilityCode_PAGE_MASK">
      <summary>Page mask for transport capability code</summary>
    </member>
    <member
      name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE2_BASIC_PAGE">
      <summary>Message Version 2 transport capability page code</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE2_BASIC_ENABLE">
      <summary>Enable Message Version 2 transport capability flag</summary>
    </member>
    <member
      name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE2_BASIC_CONNECTCOMBINED">
      <summary>Enable Message Version 2 connect combined transport capability flag</summary>
    </member>
    <member
      name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE4_BASIC_PAGE">
      <summary>Message Version 4 transport capability page code</summary>
    </member>
    <member name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE4_BASIC_ENABLE">
      <summary>Enable Message Version 4 transport capability flag</summary>
    </member>
    <member
      name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE4_BASIC_CONNECTCOMBINED">
      <summary>Enable Message Version 4 connect combine transport capability flag</summary>
    </member>
    <member
      name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE4_STRINGTABLE_PAGE">
      <summary>Message Version 4 String Table capability page code</summary>
    </member>
    <member
      name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE4_STRINGTABLE_ENABLE">
      <summary>Enable Message Version 4 String Table transport capability code</summary>
    </member>
    <member
      name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE4_STRINGTABLE_MESSAGE_LOCAL2">
      <summary>Enable Message Version 4 local String Table capability code</summary>
    </member>
    <member
      name="P:RobotRaconteur.RobotRaconteurNET.TransportCapabilityCode_MESSAGE4_STRINGTABLE_STANDARD_TABLE4">
      <summary>Enable Message Version 4 standard String Table capability code</summary>
    </member>


    <member name="T:RobotRaconteur.MessageEntryType">
      <summary>
        Message entry type codes
      </summary>
      <remarks>
        Message entries are sent between nodes stored in messages, and represent
        requests, responses, or packets. The type of the entry is specified through
        the message entry type code. These type codes are similar to op-codes. This
        enum contains the defined entry type codes.

        Odd codes represent requests or packets, even codes
        represent responses.

        Entry types less than 500 are considered "special requests" that can be used
        before a session is established.
      </remarks>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.Null">
      <summary>no-op</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.StreamOp">
      <summary>Stream operation request (transport only)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.StreamOpRet">
      <summary>Stream operation response (transport only)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.StreamCheckCapability">
      <summary>Stream check capability request (transport only)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.StreamCheckCapabilityRet">
      <summary>Stream check capability response (transport only)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.GetServiceDesc">
      <summary>Get service definition request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.GetServiceDescRet">
      <summary>Get service definition response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ObjectTypeName">
      <summary>Get object qualified type name request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ObjectTypeNameRet">
      <summary>Get object qualified type name response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ServiceClosed">
      <summary>Service closed notification packet</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ServiceClosedRet">
      <summary>(reserved)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ConnectClient">
      <summary>Connect client request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ConnectClientRet">
      <summary>Connect client response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.DisconnectClient">
      <summary>Disconnect client request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.DisconnectClientRet">
      <summary>Disconnect client response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ConnectionTest">
      <summary>Ping request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ConnectionTestRet">
      <summary>Pong response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.GetNodeInfo">
      <summary>Get node information request (NodeID and NodeName)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.GetNodeInfoRet">
      <summary>Get node information response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ReconnectClient">
      <summary>(reserved)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ReconnectClientRet">
      <summary>(reserved)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.NodeCheckCapability">
      <summary>Get node capability request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.NodeCheckCapabilityRet">
      <summary>Get node capability response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.GetServiceAttributes">
      <summary>Get service attributes request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.GetServiceAttributesRet">
      <summary>Get service attributes response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ConnectClientCombined">
      <summary>Connect client combined operation request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ConnectClientCombinedRet">
      <summary>Connect client combined operation response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.EndpointCheckCapability">
      <summary>Get endpoint capability request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.EndpointCheckCapabilityRet">
      <summary>Get endpoint capabalitiy response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ServiceCheckCapabilityReq">
      <summary>Get service capability request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ServiceCheckCapabilityRet">
      <summary>Get service capability response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ClientKeepAliveReq">
      <summary>Client keep alive request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ClientKeepAliveRet">
      <summary>Client keep alive response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ClientSessionOpReq">
      <summary>Client session management operation request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ClientSessionOpRet">
      <summary>Client session management operation response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ServicePathReleasedReq">
      <summary>Service path released event notification packet</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.ServicePathReleasedRet">
      <summary>(reserved)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PropertyGetReq">
      <summary>Property member get request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PropertyGetRes">
      <summary>Property member get response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PropertySetReq">
      <summary>Property member set request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PropertySetRes">
      <summary>Property member set response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.FunctionCallReq">
      <summary>Function member call request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.FunctionCallRes">
      <summary>Function member call response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.GeneratorNextReq">
      <summary>Generater next call request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.GeneratorNextRes">
      <summary>Generater next call response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.EventReq">
      <summary>Event member notification</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.EventRes">
      <summary>(reserved)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PipePacket">
      <summary>Pipe member packet</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PipePacketRet">
      <summary>Pipe member packet ack</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PipeConnectReq">
      <summary>Pipe member connect request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PipeConnectRet">
      <summary>Pipe member connect response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PipeDisconnectReq">
      <summary>Pipe member close request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PipeDisconnectRet">
      <summary>Pipe member close response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PipeClosed">
      <summary>Pipe member closed event notification packet</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.PipeClosedRet">
      <summary>(reserved)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.CallbackCallReq">
      <summary>Callback member call request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.CallbackCallRet">
      <summary>Callback member call response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WirePacket">
      <summary>Wire member value packet</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WirePacketRet">
      <summary>(reserved)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WireConnectReq">
      <summary>Wire member connect request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WireConnectRet">
      <summary>Wire member connect response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WireDisconnectReq">
      <summary>Wire member close request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WireDisconnectRet">
      <summary>Wire member close response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WireClosed">
      <summary>Wire member closed event notification packet</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WireClosedRet">
      <summary>(reserved)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.MemoryRead">
      <summary>Memory member read request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.MemoryReadRet">
      <summary>Memory member read response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.MemoryWrite">
      <summary>Memory member write request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.MemoryWriteRet">
      <summary>Memory member write response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.MemoryGetParam">
      <summary>Memory member get param request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.MemoryGetParamRet">
      <summary>Memory member get param response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WirePeekInValueReq">
      <summary>Wire member peek InValue request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WirePeekInValueRet">
      <summary>Wire member peek InValue response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WirePeekOutValueReq">
      <summary>Wire member peek OutValue request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WirePeekOutValueRet">
      <summary>Wire member peek OutValue response</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WirePokeOutValueReq">
      <summary>Wire member poke OutValue request</summary>
    </member>
    <member name="F:RobotRaconteur.MessageEntryType.WirePokeOutValueRet">
      <summary>Wire member poke OutValue response</summary>
    </member>

    <member name="T:RobotRaconteur.MessageErrorType">
      <summary>
        Message error type codes enum
      </summary>
    </member>

    <member name="F:RobotRaconteur.MessageErrorType.None">
      <summary>success</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ConnectionError">
      <summary>connection error</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ProtocolError">
      <summary>protocol error serializing messages</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ServiceNotFound">
      <summary>specified service not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ObjectNotFound">
      <summary>specified object not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.InvalidEndpoint">
      <summary>specified endpoint not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.EndpointCommunicationFatalError">
      <summary>communication with specified endpoint failed</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.NodeNotFound">
      <summary>specified node not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ServiceError">
      <summary>service error</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.MemberNotFound">
      <summary>specified member not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.MemberFormatMismatch">
      <summary>message format incompatible with specified member</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.DataTypeMismatch">
      <summary>data type did not match expected type</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.DataTypeError">
      <summary>data type failure</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.DataSerializationError">
      <summary>failure serializing data type</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.MessageEntryNotFound">
      <summary>specified message entry not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.MessageElementNotFound">
      <summary>specified message element not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.UnknownError">
      <summary>unknown exception occurred check `error name`</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.InvalidOperation">
      <summary>invalid operation attempted</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.InvalidArgument">
      <summary>argument is invalid</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.OperationFailed">
      <summary>the requested operation failed</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.NullValue">
      <summary>invalid null value</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.InternalError">
      <summary>internal error</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.SystemResourcePermissionDenied">
      <summary>permission denied to a system resource</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.OutOfSystemResource">
      <summary>system resource has been exhausted</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.SystemResourceError">
      <summary>system resource error</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ResourceNotFound">
      <summary>a required resource was not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.IOError">
      <summary>input/output error</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.BufferLimitViolation">
      <summary>a buffer underrun/overrun has occurred</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ServiceDefinitionError">
      <summary>service definition parse or validation error</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.OutOfRange">
      <summary>attempt to access an out of range element</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.KeyNotFound">
      <summary>key not found</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.InvalidConfiguration">
      <summary>invalid configuration specified</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.InvalidState">
      <summary>invalid state</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.RemoteError">
      <summary>error occurred on remote node</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.RequestTimeout">
      <summary>request timed out</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ReadOnlyMember">
      <summary>attempt to write to a read only member</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.WriteOnlyMember">
      <summary>attempt to read a write only member</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.NotImplementedError">
      <summary>member not implemented</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.MemberBusy">
      <summary>member is busy try again</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ValueNotSet">
      <summary>value has not been set</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.AbortOperation">
      <summary>abort operation (generator only)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.OperationAborted">
      <summary>the operation has been aborted</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.StopIteration">
      <summary>stop generator iteration (generator only)</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.OperationTimeout">
      <summary>the operation has timed out</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.OperationCancelled">
      <summary>the operation has been cancelled</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.AuthenticationError">
      <summary>authentication has failed</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.ObjectLockedError">
      <summary>the object is locked by another user or session</summary>
    </member>
    <member name="F:RobotRaconteur.MessageErrorType.PermissionDenied">
      <summary>permission to service object or resource denied</summary>
    </member>


    <member name="T:RobotRaconteur.ClientServiceListenerEventType">
      <summary>
        Enum of client listener events
      </summary>
    </member>

    <member name="F:RobotRaconteur.ClientServiceListenerEventType.ClientClosed">
      <summary>client has been closed</summary>
    </member>
    <member name="F:RobotRaconteur.ClientServiceListenerEventType.ClientConnectionTimeout">
      <summary>client connection has timed out</summary>
    </member>
    <member name="F:RobotRaconteur.ClientServiceListenerEventType.TransportConnectionConnected">
      <summary>client transport has been connected</summary>
    </member>
    <member name="F:RobotRaconteur.ClientServiceListenerEventType.TransportConnectionClosed">
      <summary>client transport connection has been closed or lost</summary>
    </member>
    <member name="F:RobotRaconteur.ClientServiceListenerEventType.ServicePathReleased">
      <summary>client has received notification that service path was released</summary>
    </member>

    <member name="T:RobotRaconteur.ServiceServiceListenerEventType">
      <summary>
        Enum of service listener events
      </summary>
    </member>

    <member name="F:RobotRaconteur.ServerServiceListenerEventType.ServiceClosed">
      <summary>service has been closed</summary>
    </member>
    <member name="F:RobotRaconteur.ServerServiceListenerEventType.ClientConnected">
      <summary>client has connected</summary>
    </member>
    <member name="F:RobotRaconteur.ServerServiceListenerEventType.ClientDisconnected">
      <summary>client has disconnected</summary>
    </member>

    <member name="T:RobotRaconteur.MemberDefinition_Direction">
      <summary>
        Member direction enum
</summary>
<remarks>        
  Use member modifiers to declare member direction (readonly,writeonly)
      </remarks>
    </member>

    <member name="F:RobotRaconteur.MemberDefinition_Direction.Direction_both">
      <summary>member supports read and write</summary>
    </member>
    <member name="F:RobotRaconteur.MemberDefinition_Direction.Direction_readonly">
      <summary>member is readonly</summary>
    </member>
    <member name="F:RobotRaconteur.MemberDefinition_Direction.Directionwriteonly">
      <summary>member is writeonly</summary>
    </member>

    <member name="T:RobotRaconteur.MemberDefinition_NoLock">
      <summary>
        Member locking options enum
</summary>
<remarks>
        Use member modifiers to declare lock options
</remarks>
    </member>

    <member name="F:RobotRaconteur.MemberDefinition_NoLock.NoLock_none">
      <summary>member cannot be accessed by other users/sessions when object is locked</summary>
    </member>
    <member name="F:RobotRaconteur.MemberDefinition_NoLock.NoLock_all">
      <summary>member can be accessed by other users/sessions when object is locked</summary>
    </member>
    <member name="F:RobotRaconteur.MemberDefinition_NoLock.NoLock_read">
      <summary>member can be read by other users/sessions when object is locked</summary>
    </member>

    <member name="T:RobotRaconteur.LogLevel">
      <summary>
        Log level enum
</summary>
<remarks>
        Enum of possible log levels. Set log level using
        RobotRaconteurNode::SetLogLevel(),
        `ROBOTRACONTEUR_LOG_LEVEL` environmental variable, or
        `--robotraconteur-log-level` node setup command line option
      </remarks>
    </member>

    <member name="F:RobotRaconteur.LogLevel.LogLevel_Trace">
      <summary>`trace` log level</summary>
    </member>
    <member name="F:RobotRaconteur.LogLevel.LogLevel_Debug">
      <summary>`debug` log level</summary>
    </member>
    <member name="F:RobotRaconteur.LogLevel.LogLevel_Info">
      <summary>`info` log level</summary>
    </member>
    <member name="F:RobotRaconteur.LogLevel.LogLevel_Warning">
      <summary>`warning` log level</summary>
    </member>
    <member name="F:RobotRaconteur.LogLevel.LogLevel_Error">
      <summary>`error` log level</summary>
    </member>
    <member name="F:RobotRaconteur.LogLevel.LogLevel_Fatal">
      <summary>`fatal` log level</summary>
    </member>
    <member name="F:RobotRaconteur.LogLevel.LogLevel_Disable">
      <summary>`disabled` log level</summary>
    </member>


    <member name="T:RobotRaconteur.LogComponent">
      <summary>
        Log component enum
</summary>
<remarks>
        Log records contain the code of the component where
        the log record was generated
      </remarks>
    </member>

    <member name="F:RobotRaconteur.LogComponent.LogComponent_Default">
      <summary>default component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Node">
      <summary>Robot Raconteur Node component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Transport">
      <summary>tranport component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Message">
      <summary>message or message serialization component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Client">
      <summary>client component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Service">
      <summary>service component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Member">
      <summary>member component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Pack">
      <summary>data message packing component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Unpack">
      <summary>data message unpacknig component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_ServiceDefinition">
      <summary>service definition parser component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Discovery">
      <summary>node/service discovery component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Subscription">
      <summary>subscription component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_NodeSetup">
      <summary>node setup component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_Utility">
      <summary>utility component</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_RobDefLib">
      <summary>service definition standard library component (external)</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_User">
      <summary>user component (external)</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_UserClient">
      <summary>user client component (external)</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_UserService">
      <summary>user service component (external)</summary>
    </member>
    <member name="F:RobotRaconteur.LogComponent.LogComponent_ThirdParty">
      <summary>third party library component (external)</summary>
    </member>

    <!-- RobotRaconteurNode.h -->

    <member name="T:RobotRaconteur.RobotRaconteurObjectLockFlags">
      <summary>
        The type of object lock
      </summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurObjectLockFlags.CLIENT_LOCK">
      <summary>
        Client level lock
</summary>
<remarks>
        Only the current client connection will have access
        to the locked object
      </remarks>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurObjectLockFlags.USER_LOCK">
      <summary>
        User level lock
</summary>
<remarks>
        The object will be accesible for all client connections
        authenticated by the current user
      </remarks>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.RegisterTransport">
      <summary>
        Register a transport for use by the node
      </summary>
      <param name="transport">The transport to register</param>
      <returns>The transport internal id</returns>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.SelectRemoteNodeURL(RobotRaconteur.vectorstring)">
      <summary>
        Select the "best" URL from a std::vector of candidates
</summary>
<remarks>
        Service discovery will often return a list of candidate URLs to
        use to connect to a node. This function uses hueristics to select
        the "best" URL to use. The selection criteria ranks URLs in roughly
        the following order, lower number being better:

        <list type="number">
          <term>"rr+intra" for IntraTransport</term>
          <term>"rr+local" for LocalTransport</term>
          <term>"rr+pci" or "rr+usb" for HardwareTransport</term>
          <term>"rrs+tcp://127.0.0.1" for secure TcpTransport loopback</term>
          <term>"rrs+tcp://[::1]" for secure TcpTransport IPv6 loopback</term>
          <term>"rrs+tcp://localhost" for secure TcpTransport loopback</term>
          <term>"rrs+tcp://[fe80" for secure TcpTransport link-local IPv6</term>
          <term>"rrs+tcp://" for any secure TcpTransport</term>
          <term>"rr+tcp://127.0.0.1" for TcpTransport loopback</term>
          <term>"rr+tcp://[::1]" for TcpTransport IPv6 loopback</term>
          <term>"rr+tcp://localhost" for TcpTransport loopback</term>
          <term>"rr+tcp://[fe80" for TcpTransport link-local IPv6</term>
          <term>"rr+tcp://" for any TcpTransport</term>
          </list>
      </remarks>
      <param name="urls">The candidate URLs</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.UnregisterServiceType">
      <summary>
        Unregister a previously registered service type
</summary>
<remarks>
        This function is not recommended as the results can be
        unpredicatle
      </remarks>
      <param name="type">The type to unregister</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.IsServiceTypeRegistered">
      <summary>
        Check if a service type has been registered
      </summary>
      <param name="type">The name of the service type to check</param>
      <returns>true if registered, otherwise false</returns>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.CloseService">
      <summary>
        Closes a previously registered service
</summary>
<remarks>
        Services are automatically closed by Shutdown, so this function
        is rarely used.
      </remarks>
      <param name="sname">The name of the service to close</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.CheckConnection">
      <summary>
        Check that the TransportConnection associated with an endpoint
        is connected
      </summary>
      <param name="endpoint">The LocalEndpoint identifier to check</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.Sleep">
      <summary>
        Sleeps for a specified duration
</summary>
<remarks>
        Normally will sleep based on the system clock, but in certain
        circumstances will use simulation time
      </remarks>
      <param name="duration">Duration to sleep in milliseconds</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.CreateRate">
      <summary>
        Create a Rate object
</summary>
<remarks>
        Rate is used to stabilize periodic loops to a specified frequency

        This function will normally return a WallRate instance
      </remarks>
      <param name="frequency">Frequency of loop in Hz</param>
      <returns>The new Rate object</returns>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.CreateAutoResetEvent">
      <summary>
        Create an AutoResetEvent object
</summary>
<remarks>
        Normally the AutoResetEvent will use the system clock for timeouts,
        but in certain circumstances will use simulation time
      </remarks>
      <returns>The new AutoResetEvent object</returns>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.CompareLogLevel">
      <summary>
        Test if the specified log level would be accepted
      </summary>
      <param name="log_level">Log level to test</param>
      <returns>true if the log would be accepted</returns>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.LogMessage">
      <summary>
        Log a simple message using the current node
</summary>
<remarks>
        The record will be sent to the configured log handler,
        or sent to std::cerr if none is configured

        If the level of the message is below the current log level
        for the node, the record will be ignored
      </remarks>
      <param name="level">The level for the log message</param>
      <param name="message">The log message</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.LogRecord">
      <summary>
        Log a record to the node.
</summary>
<remarks>
        The record will be sent to the configured log handler,
        or sent to stderr if none is configured

        If the level of the message is below the current log level
        for the node, it will be ignored
      </remarks>
      <param name="record">The record to log</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.GetLogLevel">
      <summary>
        Get the current log level for the node
</summary>
<remarks>
        Default level is "info"
      </remarks>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.SetLogLevel">
      <summary>
        Set the log level for the node
</summary>
<remarks>
        Set RobotRaconteur.RobotRaconteur_LogLevel_Disable to disable logging
      </remarks>
      <param name="level">The desired log level</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.SetLogLevelFromString">
      <summary>
        Set the log level for the node from a string
</summary>
<remarks>
        Must be one of the following values: DISABLE, FATAL, ERROR, WARNING, INFO, DEBUG, TRACE
        Defaults to WARNING
      </remarks>
      <param name="level">The desired log level</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.SetLogLevelFromEnvVariable">
      <summary>
        Set the log level for the node from specified environmental variable
</summary>
<remarks>
        Retrieves the specified environmental variable and sets the log level based
        on one of the following values: DISABLE, FATAL, ERROR, WARNING, INFO, DEBUG, TRACE

        If an invalid value or the variable does not exist, the log level is left unchanged.
      </remarks>
      <param name="env_variable_name">The environmental variable to use. Defaults to
        `ROBOTRACONTEUR_LOG_LEVEL`</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.GetLogRecordHandler">
      <summary>
        Get the currently configured log record handler
</summary>
<remarks>
        If null, records are sent to stderr
      </remarks>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.SetLogRecordHandler">
      <summary>
        Set the handler for log records
</summary>
<remarks>
        If handler is NULL, records are sent to stderr
      </remarks>
      <param name="handler">The log record handler function</param>
    </member>

    <member name="M:RobotRaconteur.RobotRaconteurNode.GetRegisteredServiceTypes">
      <summary>
        Return names of registered service types
      </summary>
      <returns>The registered service types</returns>
    </member>

    <member name="T:RobotRaconteur.ConnectionException">
      <summary>
        Exception thrown when connection to remote node fails
</summary>
<remarks>
        This exception is thrown if a connection cannot be created,
        the connection fails, or the connection has been closed.
        Error code MessageErrorType_ConnectionError (1)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.ConnectionException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ConnectionException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ProtocolException">
      <summary>
        Exception thrown when a protocol failure occurs on
        a tranport connection

        Error code MessageErrorType_ProtocolError (2)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.ProtocolException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ProtocolException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ServiceNotFoundException">
      <summary>
        Exception thrown when a service cannot be found
        on a remote node

        Error code MessageErrorType_ServiceNotFound (3)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.ServiceNotFoundException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ServiceNotFoundException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ObjectNotFoundException">
      <summary>
        Exception thrown when a service object cannot
        be found

        This error is thrown when a specified service path
        does not have an assosciate object. The object may
        have been released by the service, or the service
        path is invalid

        Error code MessageErrorType_ObjectNotFound (4)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.ObjectNotFoundException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ObjectNotFoundException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.InvalidEndpointException">
      <summary>
        Exception thrown when an attempt is made
        to send a message to an invalid endpoint

        Transports between two nodes terminate with a pair
        of endpoints, one in each node. If the client, service,
        service endpoint, or transport is destroyed, the endpoint
        will be deleted. This exception is thrown if the
        target endpoint is no longer available.

        Error code MessageErrorType_InvalidEndpoint (5)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.InvalidEndpointException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a InvalidEndpointException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.EndpointCommunicationFatalException">
      <summary>
        Exception thrown when an attempt to send a
        message to an endpoint fails

        Transports between two nodes terminate with a pair
        of endpoints, one in each node. Messages are sent
        between endpoint pairs. If for some reason the endpoint
        cannot send (or receive) the message, this exception
        is thrown.

        Error code MessageErrorType_EndpointCommunicationFatalError (6)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.EndpointCommunicationFatalException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a EndpointCommunicationFatalException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.NodeNotFoundException">
      <summary>
        Exception thrown if the specified node cannot be found
</summary>
<remarks>
        When connecting to a service or sending a message, the NodeID
        and/or NodeName are specified. If the specified node
        cannot be found, this exception is thrown.

        Error code MessageErrorType_NodeNotFound (7)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.NodeNotFoundException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a NodeNotFoundException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ServiceException">
      <summary>
        Exception thrown when an exception occurs during
        an operation on a service

        ServiceException is a catch-all error for exceptions on services.
        See the message field for an explanation of the error that occured.

        Error code MessageErrorType_ServiceError (8)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.ServiceException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ServiceException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.MemberNotFoundException">
      <summary>
        Exception thrown when the specified object member is
        not found

        Service objects have member that are declared in a service definition.
        If an attempt is made to call a member that does not exist, this exception
        is thrown.

        Error code MessageErrorType_MemberNotFound (9)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.MemberNotFoundException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a MemberNotFoundException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.MemberFormatMismatchException">
      <summary>
        Exception thrown when a request to a member has an
        invalid MessageEntryType or the wrong message elements

        Error code MessageErrorType_MemberFormatMismatch (10)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.MemberFormatMismatchException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a MemberFormatMismatchException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.DataTypeMismatchException">
      <summary>
        Exception thrown when incorrect data is received
        by a member

        Make sure the provided data matches the expected data types

        Error code MessageErrorType_DataTypeMismatch (11)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.DataTypeMismatchException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a DataTypeMismatchException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.DataTypeException">
      <summary>
        Exception thrown when unexpected or incompatible
        data is provided

        DataTypeException is sometimes thrown when there is a
        type mismatch instead of DataTypeMismatchException

        Make sure the provided data matches the expected data types

        Error code MessageErrorType_DataTypeError (12)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.DataTypeException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a DataTypeException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.DataSerializationException">
      <summary>
        Exception thrown when data cannot be serialized
</summary>
<remarks>
        This exeception is thrown when the provide data cannot be serialized.
        This typically occurs inside a transport.

        Check that the provided data matches the types supported by
        the Robot Raconteur C++ library

        Error code MessageErrorType_DataSerializationError (13)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.DataSerializationException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a DataSerializationException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.MessageEntryNotFoundException">
      <summary>
        Exception thrown when an expected MessageEntry
        is not found

        Error code MessageErrorType_MessageEntryNotfound (14)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.MessageEntryNotFoundException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a MessageEntryNotFoundException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.MessageElementNotFoundException">
      <summary>
        Exception thrown wen an expected MessageElement
        is not found

        This exception is thrown when an expected field or parameter
        is not found.

        Error code MessageErrorType_MessageElementNotfound (15)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.MessageElementNotFoundException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a MessageElementNotFoundException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.UnknownException">
      <summary>
        Exception representing an unknown exception type
</summary>
<remarks>
        This exception is used to transmit exceptions that do not have a
        MessageErrorType code. Check the Error field for the name
        of the exception.

        Error code MessageErrorType_UnknownError (16)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.UnknownException.#ctor(System.String,System.String,System.String,System.Object)">
      <summary>
        Construct a UnknownException
      </summary>
      <param name="error">The name of the exception</param>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>


    <member name="T:RobotRaconteur.InvalidOperationException">
      <summary>
        Exception thrown when an invalid operation is attempted
</summary>
<remarks>
        Error code MessageErrorType_InvalidOperation (17)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.InvalidOperationException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a InvalidOperationException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.InvalidArgumentException">
      <summary>
        Exception thrown for an invalid argument
</summary>
<remarks>
        Error code MessageErrorType_InvalidArgument (18)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.InvalidArgumentException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a InvalidArgumentException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.OperationFailedException">
      <summary>
        Exception thrown when an operation fails
</summary>
<remarks>
        Error code MessageErrorType_OperationFailed (19)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.OperationFailedException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a OperationFailedException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.NullValueException">
      <summary>
        Exception thrown for an unexpected null value
</summary>
<remarks>
        Error code MessageErrorType_NullValue (20)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.NullValueException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a NullValueException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.InternalErrorException">
      <summary>
        Exception thrown when an internal error has occurred
</summary>
<remarks>
        Error code MessageErrorType_InternalError (21)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.InternalErrorException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a InternalErrorException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.PermissionDeniedException">
      <summary>
        Exception thrown when permission is denied to a service member
</summary>
<remarks>
        Error code MessageErrorType_PermissionDenied (152)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.PermissionDeniedException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a PermissionDeniedException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.SystemResourcePermissionDeniedException">
      <summary>
        Exception thrown when permission to a system resource is denied
</summary>
<remarks>
        Error code MessageErrorType_SystemResourcePermissionDenied (22)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.SystemResourcePermissionDeniedException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a SystemResourcePermissionDeniedException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.OutOfSystemResourceException">
      <summary>
        Exception thrown when a system resource has been exhausted
</summary>
<remarks>
        Error code MessageErrorType_OutOfsystemResource (23)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.OutOfSystemResourceException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a OutOfSystemResourceException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.SystemResourceException">
      <summary>
        Exception thrown when a system resource error occurs
</summary>
<remarks>
        Error code MessageErrorType_SystemResourceException (24)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.SystemResourceException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a SystemResourceException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ResourceNotFoundException">
      <summary>
        Exception thrown when a system resource is not found
</summary>
<remarks>
        Error code MessageErrorType_ResourceNotFound (25)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.ResourceNotFoundException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ResourceNotFoundException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.IOException">
      <summary>
        Exception thrown when an input/output error occurs
</summary>
<remarks>
        Error code MessageErrorType_IOError (26)
      </remarks>
    </member>
    <member name="M:RobotRaconteur.IOException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a IOException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.BufferLimitViolationException">
      <summary>
        Exception thrown when a transport buffer limit is violated
</summary>
<remarks>
        This exception typically occurs if there is a bug in
        serialization/deserialization, or the data stream
        has been corrupted

        Error code MessageErrorType_BufferLimitViolation (27)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.BufferLimitViolationException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a BufferLimitViolationException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ServiceDefinitionException">
      <summary>
        Exception thrown when a service definition cannot be
        parsed or fails verification

        Error code MessageErrorType_ServiceDefinitionError (28)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.ServiceDefinitionException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ServiceDefinitionException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.OutOfRangeException">
      <summary>
        Exception thrown when an attempt to acces an array or container
        index is out of range

        Error code MessageErrorType_OutOfRange (29)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.OutOfRangeException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a OutOfRangeException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.KeyNotFoundException">
      <summary>
        Exception thrown when a key is not found in a map
</summary>
<remarks>
        Error code MessageErrorType_KeyNotFound (30)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.KeyNotFoundException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a KeyNotFoundException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.InvalidConfigurationException">
      <summary>
        Exception thrown when an invalid configuration is specified or encountered
</summary>
<remarks>
        Error code MessageErrorType_InvalidConfiguration (31)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.InvalidConfigurationException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a InvalidConfigurationException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.InvalidStateException">
      <summary>
        Exception thrown when an invalid state is specified or encountered
</summary>
<remarks>
        Error code MessageErrorType_InvalidState (32)
</remarks>
    </member>
    <member
      name="M:RobotRaconteur.InvalidStateException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a InvalidStateException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.RobotRaconteurRemoteException">
      <summary>
        Exception thrown when an error occurs on a remote
        member request

        User defined exceptions declared in service definitions extend
        RobotRaconteurRemoteException

        Error code MessageErrorType_RemoteError (100)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.RobotRaconteurRemoteException.#ctor(System.String,System.String,System.String,System.Object)">
      <summary>
        Construct a RobotRaconteurRemoteException
</summary>
<remarks>
        error should be the fully qualified type of the exception
        for user defined exceptions
</remarks>
      <param name="error">The name of the exception</param>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.RequestTimeoutException">
      <summary>
        The request timed out
</summary>
<remarks>
        See RobotRaconteurNode::SetRequestTimeout(),
        or the timeout passed to an asynchronous request

        Error code MessageErrorType_RequestTimeout (101)

</remarks>
    </member>
    <member
      name="M:RobotRaconteur.RequestTimeoutException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a RequestTimeoutException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ReadOnlyMemberException">
      <summary>
        An attempt was made to write/set a read only member
</summary>
<remarks>
        Error code MessageErrorType_ReadOnlyMember (102)
</remarks>
    </member>
    <member
      name="M:RobotRaconteur.ReadOnlyMemberException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ReadOnlyMemberException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.WriteOnlyMemberException">
      <summary>
        An attempt was mode to read/get a write only member
</summary>
<remarks>
        Error code MessageErrorType_WriteOnlyMember (103)
</remarks>
    </member>
    <member
      name="M:RobotRaconteur.WriteOnlyMemberException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a WriteOnlyMemberException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.NotImplementedException">
      <summary>
        Exception thrown if a member is not implemented
</summary>
<remarks>
        Error code MessageErrorType_NotImplementedError (104)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.NotImplementedException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a NotImplementedException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.MemberBusyException">
      <summary>
        Thrown is a member is busy. Retry later
</summary>
<remarks>
        Error code MessageErrorType_MemberBusy (105)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.MemberBusyException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a MemberBusyException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ValueNotSetException">
      <summary>
        Exception thrown if a value has not been set
</summary>
<remarks>
        This exception is most often used by WireConnection.GetInValue()
        and WireConnection.GetOutValue() if InValue or OutValue
        have not been received or set

        Error code MessageErrorType_ValueNotSet (106)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.ValueNotSetException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ValueNotSetException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.AuthenticationException">
      <summary>
        Exception thrown when authentication is required or attempt
        to authenticate fails

        Error code MessageErrorType_AuthenticationError (150)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.AuthenticationException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a AuthenticationException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.ObjectLockedException">
      <summary>
        Exception thrown when attempting to access a locked
        service object

        Service objects can be locked using RobotRaconteurNode::RequestObjectLock().
        This exception is thrown if an attempt is made to access a service object
        (or sub-object) that has been locked by another user or session.

        Error code MessageErrorType_ObjectLockedError (151)
      </summary>
    </member>
    <member
      name="M:RobotRaconteur.ObjectLockedException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a ObjectLockedException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.AbortOperationException">
      <summary>
        Exception passed to generators to trigger an abort
</summary>
<remarks>
        This is typically not thrown or received by the user

        Error code MessageErrorType_AbortOperation (107)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.AbortOperationException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a AbortOperationException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.OperationAbortedException">
      <summary>
        Exception thrown when an operation is aborted
</summary>
<remarks>
        This is thrown be generator functions when Abort()
        is called

        Generators are destroyed after throwing
        OperationAbortedException during Next()

        This error is passed to generators to trigger an abort

        Error code MessageErrorType_OperationAborted (108)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.OperationAbortedException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a OperationAbortedException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.StopIterationException">
      <summary>
        Exception thrown when a generator has finished sending results
</summary>
<remarks>
        StopIterationException is not an error condition. It signals
        that a generator is finished sending results.

        This error is passed to generators to trigger a close

        Error code MessageErrorType_StopIteration (109)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.StopIterationException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a StopIterationException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.OperationTimeoutException">
      <summary>
        Exception thrown when an operation does not complete in the expected time
</summary>
<remarks>
        Error code MessageErrorType_OperationTimeout (110)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.OperationTimeoutException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a OperationTimeoutException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.OperationCancelledException">
      <summary>
        Exception thrown when an operation is cancelled before it is started
</summary>
<remarks>
        Error code MessageErrorType_OperationCancelled (111)
      </remarks>
    </member>
    <member
      name="M:RobotRaconteur.OperationCancelledException.#ctor(System.String,System.String,System.Object)">
      <summary>
        Construct a OperationCancelledException
      </summary>
      <param name="message">Message for the user</param>
      <param name="sub_name">Optional error sub_name</param>
      <param name="param_">Optional error param</param>
    </member>

    <member name="T:RobotRaconteur.RobotRaconteurNodeSetupFlags">
      <summary>
        Setup option flags
</summary>
<remarks>
        Setup option flags passed to node setup classes to select options to enable
        and disable. Flags are used to configure the following types of options:

        <list type="number">
          <term>Enable and disable transport types</term>
          <term>Modify transport options including discovery, security requirements,
          and connection listening</term>
          <term>Configure TLS behavior</term>
          <term>Enable local tap for logging</term>
          </list>

        Node setup classes also allow options and flags to be "overridden" using
        command line options. Use the `*_ALLOW_OVERRIDE` options to configure
        when these overrides are allowed.

        The ClientNodeSetup, ServerNodeSetup, and SecureServerNodeSetup
        are convenience classes for the most commonly used options.
      </remarks>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.NONE">
      <summary>No options enabled</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.ENABLE_NODE_DISCOVERY_LISTENING">
      <summary>Enable node discovery listening on all transports</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.ENABLE_NODE_ANNOUNCE">
      <summary>Enable node announce on all transports</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.ENABLE_LOCAL_TRANSPORT">
      <summary>Enable LocalTransport</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.ENABLE_TCP_TRANSPORT">
      <summary>Enable TcpTransport</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.ENABLE_HARDWARE_TRANSPORT">
      <summary>Enable HardwareTransport</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.LOCAL_TRANSPORT_START_SERVER">
      <summary>Start the LocalTransport server to listen for incoming clients</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.LOCAL_TRANSPORT_START_CLIENT">
      <summary>Start the LocalTransport client with specified node name</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.TCP_TRANSPORT_START_SERVER">
      <summary>Start the TcpTransport server to listen for incoming clients on the specified port</summary>
    </member>
    <member
      name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.TCP_TRANSPORT_START_SERVER_PORT_SHARER">
      <summary>Start the TcpTransport server to incoming for incoming clients using the port sharer</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.DISABLE_MESSAGE4">
      <summary>Disable Message Format Version 4 on all transports</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.DISABLE_STRINGTABLE">
      <summary>Disable Message Format Version 4 string table on all transports</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.DISABLE_TIMEOUTS">
      <summary>Disable all timeouts (useful for debugging)</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.LOAD_TLS_CERT">
      <summary>Load the TLS certificate for TcpTransport</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.REQUIRE_TLS">
      <summary>Require TLS for all clients on TcpTransport</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.LOCAL_TRANSPORT_SERVER_PUBLIC">
      <summary>Make LocalTransport server listen for incoming clients from all users</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.NODENAME_OVERRIDE">
      <summary>Allow NodeName to be configured using command line options</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.NODEID_OVERRIDE">
      <summary>Allow NodeID to be configured using command line options</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.TCP_PORT_OVERRIDE">
      <summary>Allow TCP port to be configured using command line options</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.TCP_WEBSOCKET_ORIGIN_OVERRIDE">
      <summary>Allow TCP WebSocket origin control to be configured using command line options</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.ENABLE_INTRA_TRANSPORT">
      <summary>Enable IntraTransport</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.INTRA_TRANSPORT_START_SERVER">
      <summary>Start the IntraTransport server to listen for incoming clients</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.LOCAL_TAP_ENABLE">
      <summary>Enable the LocalTap debug logging system</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.LOCAL_TAP_NAME">
      <summary>Allow the user to set the LocalTap name</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.ENABLE_ALL_TRANSPORTS">
      <summary>Convenience flag to enable all transports</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.CLIENT_DEFAULT">
      <summary>Default configuration for client nodes (See ClientNodeSetup)</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.CLIENT_DEFAULT_ALLOWED_OVERRIDE">
      <summary>Default allowed overrides for client nodes (See ClientNodeSetup)</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.SERVER_DEFAULT">
      <summary>Default configuration for server nodes</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.SERVER_DEFAULT_ALLOWED_OVERRIDE">
      <summary>Default allowed overrides for server nodes</summary>
    </member>
    <member name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.SECURE_SERVER_DEFAULT">
      <summary>Default configuration for server nodes requiring TLS network transports</summary>
    </member>
    <member
      name="F:RobotRaconteur.RobotRaconteurNodeSetupFlags.SECURE_SERVER_DEFAULT_ALLOWED_OVERRIDE">
      <summary>Default allowed overrides for server nodes requiring TLS network transports</summary>
    </member>

    <member name="T:RobotRaconteur.CommandLineConfigParser">
      <summary>
        Command line parser for node setup classes
</summary>
<remarks>
        The CommandLineConfigParser is used to parse command line options specified
        when a program is launched. These options allow for the node configuration to be
        changed without recompiling the software. See command_line_options for
        a table of the standard command line options.

        ClientNodeSetup, ServerNodeSetup, and SecureServerNodeSetup use this class to parse
        the `sys.argv` parameters. The RobotRaconteurNodeSetup constructors will accept
        either `sys.argv`, or will accept an initialize CommandLineConfigParser.

        The CommandLineConfig() constructor takes the "allowed override" flags, and the option
        prefix.
        The "allowed override" specifies which options can be overridden using the command line. The
        prefix option allows the command line flag prefix to be changed. By default it expects
        all options to begin with `--robotraconteur-` followed by the name of the option. If there
        are
        multiple nodes, it is necessary to change the prefix to be unique for each node. For
        instance,
        "robotraconteur1-" for the first node and "RobotRaconteur-" for the second node.

        Users may add additional options to the parser. Use AddStringOption(),
        AddBoolOption(), or AddIntOption() to add additional options.
      </remarks>
    </member>

    <member
      name="M:RobotRaconteur.CommandLineConfigParser.SetDefaults(System.String,System.UInt16,System.UInt32)">
      <summary>
        Set the default NodeName, TCP port, and flags
</summary>
<remarks>
        The command line options will be allowed to override the options
        specified in allowed_overrides passed to CommandLineConfigParser().
      </remarks>
      <param name="node_name">The default NodeName</param>
      <param name="tcp_port">The default TCP port</param>
      <param name="default_flags">The default flags</param>
    </member>

    <member
      name="M:RobotRaconteur.CommandLineConfigParser.AddStringOption(System.String,System.String)">
      <summary>
        Add a new string option
      </summary>
      <param name="name">The name of the option</param>
      <param name="descr">Description of the option</param>
    </member>

    <member
      name="M:RobotRaconteur.CommandLineConfigParser.AddBoolOption(System.String,System.String)">
      <summary>
        Add a new bool option
      </summary>
      <param name="name">The name of the option</param>
      <param name="descr">Description of the option</param>
    </member>

    <member
      name="M:RobotRaconteur.CommandLineConfigParser.AddIntOption(System.String,System.String)">
      <summary>
        Add a new int option
      </summary>
      <param name="name">The name of the option</param>
      <param name="descr">Description of the option</param>
    </member>

    <member name="M:RobotRaconteur.CommandLineConfigParser.ParseCommandLine(System.String[])">
      <summary>
        Parse a specified string vector containing the options
</summary>
<remarks>
        Results are stored in the instance
</remarks>
      <param name="args">The options as a string list</param>
    </member>

    <member
      name="M:RobotRaconteur.CommandLineConfigParser.GetOptionOrDefaultAsString(System.String)">
      <summary>
        Get the option value as a string
</summary>
<remarks>
        Returns empty string if option not specified on command line
</remarks>
      <param name="option">The name of the option</param>
      <returns>The option value, or an empty string</returns>
    </member>

    <member
      name="M:RobotRaconteur.CommandLineConfigParser.GetOptionOrDefaultAsString(System.String,System.String)">
      <summary>
        Get the option value as a string
</summary>
<remarks>
        Returns default_value if option not specified on command line
      </remarks>
      <param name="option">The name of the option</param>
      <param name="default_value">The default option value</param>
      <returns>The option value, or default_value if not specified on command line</returns>
    </member>

    <member name="M:RobotRaconteur.CommandLineConfigParser.GetOptionOrDefaultAsBool(System.String)">
      <summary>
        Get the option value as a bool
</summary>
<remarks>
        Returns false if option not specified on command line
      </remarks>
      <param name="option">The name of the option</param>
      <returns>The option value, or false</returns>
    </member>

    <member
      name="M:RobotRaconteur.CommandLineConfigParser.GetOptionOrDefaultAsBool(System.String,System.Boolean)">
      <summary>
        Get the option value as a bool
</summary>
<remarks>
        Returns default_value if option not specified on command line
      </remarks>
      <param name="option">The name of the option</param>
      <param name="default_value">The default option value</param>
      <returns>The option value, or default_value if not specified on command line</returns>
    </member>

    <member name="M:RobotRaconteur.CommandLineConfigParser.GetOptionOrDefaultAsInt(System.String)">
      <summary>
        Get the option value as an int
</summary>
<remarks>
        Returns -1 if option not specified on command line
      </remarks>
      <param name="option">The name of the option</param>
      <returns>The option value, or -1</returns>
    </member>

    <member
      name="M:RobotRaconteur.CommandLineConfigParser.GetOptionOrDefaultAsInt(System.String,System.Int32)">
      <summary>
        Get the option value as an int
</summary>
<remarks>
        Returns default_value if option not specified on command line
      </remarks>
      <param name="option">The name of the option</param>
      <param name="default_value">The default option value</param>
      <returns>The option value, or default_value if not specified on command line</returns>
    </member>

    <member name="M:RobotRaconteur.CommandLineConfigParser.#ctor(System.UInt32)">
      <summary>
        Construct a new CommandLineConfigParser
      </summary>
      <param name="allowed_overrides">The allowed overrides flags</param>
    </member>

    <member name="M:RobotRaconteur.CommandLineConfigParser.#ctor(System.UInt32,System.String)">
      <summary>
        Construct a new CommandLineConfigParser
      </summary>
      <param name="allowed_overrides">The allowed overrides flags</param>
      <param name="prefix">The prefix to use for the options</param>
    </member>

    <member name="T:RobotRaconteur.TimeSpec">
      <summary>
        Represents. a point in time. Used by `wire` members to
        timestamp packets

        Time is always in UTC

        Time is relative to the UNIX epoch "1970-01-01T00:00:00Z"
      </summary>
    </member>
    <member name="P:RobotRaconteur.TimeSpec.seconds">
      <summary>
        Seconds since epoch
      </summary>
    </member>
    <member name="P:RobotRaconteur.TimeSpec.nanoseconds">
      <summary>
        Nanoseconds from epoch. Normalized to be between 0 and 1e9-1
      </summary>
    </member>
    <member name="M:RobotRaconteur.TimeSpec.#ctor">
      <summary>
        Construct empty timespec
      </summary>
    </member>
    <member name="M:RobotRaconteur.TimeSpec.#ctor(System.Int64,System.Int32)">
      <summary>
        Construct timespec with specified time
      </summary>
      <param name="seconds">Seconds since epoch</param>
      <param name="nanoseconds">Nanoseconds since epoch</param>
    </member>
    <member
      name="M:RobotRaconteur.TimeSpec.op_Equality(RobotRaconteur.TimeSpec,RobotRaconteur.TimeSpec)">
      <summary>
        equality comparison
      </summary>
      <param name="a"></param>
      <param name="b"></param>
      <returns></returns>
    </member>
    <member name="M:RobotRaconteur.TimeSpec.Equals(System.Object)">
      <summary>
        Object equality operator
      </summary>
      <param name="o"></param>
      <returns></returns>
    </member>
    <member name="M:RobotRaconteur.TimeSpec.GetHashCode">
      <summary>
        Hash code
      </summary>
      <returns></returns>
    </member>
    <member
      name="M:RobotRaconteur.TimeSpec.op_Inequality(RobotRaconteur.TimeSpec,RobotRaconteur.TimeSpec)">
      <summary>
        inequality comparison
      </summary>
      <param name="a"></param>
      <param name="b"></param>
      <returns></returns>
    </member>
    <member
      name="M:RobotRaconteur.TimeSpec.op_Addition(RobotRaconteur.TimeSpec,RobotRaconteur.TimeSpec)">
      <summary>
        addition operator
      </summary>
      <param name="a"></param>
      <param name="b"></param>
      <returns></returns>
    </member>
    <member
      name="M:RobotRaconteur.TimeSpec.op_Subtraction(RobotRaconteur.TimeSpec,RobotRaconteur.TimeSpec)">
      <summary>
        subtraction operator
      </summary>
      <param name="a"></param>
      <param name="b"></param>
      <returns></returns>
    </member>
    <member
      name="M:RobotRaconteur.TimeSpec.op_GreaterThan(RobotRaconteur.TimeSpec,RobotRaconteur.TimeSpec)">
      <summary>
        greater-than comparison
      </summary>
      <param name="a"></param>
      <param name="b"></param>
      <returns></returns>
    </member>
    <member
      name="M:RobotRaconteur.TimeSpec.op_LessThan(RobotRaconteur.TimeSpec,RobotRaconteur.TimeSpec)">
      <summary>
        less-then comparison
      </summary>
      <param name="a"></param>
      <param name="b"></param>
      <returns></returns>
    </member>
    <member
      name="M:RobotRaconteur.TimeSpec.op_GreaterThanOrEqual(RobotRaconteur.TimeSpec,RobotRaconteur.TimeSpec)">
      <summary>
        greater-than-or-equal comparison
      </summary>
      <param name="a"></param>
      <param name="b"></param>
      <returns></returns>
    </member>
    <member
      name="M:RobotRaconteur.TimeSpec.op_LessThanOrEqual(RobotRaconteur.TimeSpec,RobotRaconteur.TimeSpec)">
      <summary>
        less-than-or-equal comparison
      </summary>
      <param name="a"></param>
      <param name="b"></param>
      <returns></returns>
    </member>
    <member name="M:RobotRaconteur.TimeSpec.cleanup_nanosecs">
      <summary>
        normalize nanoseconds to be within 0 and 1e9-1
      </summary>
    </member>

    <member name="T:RobotRaconteur.HardwareTransport">
      <summary>
        Transport for USB, Bluetooth, and PCIe hardware devices
</summary>
<remarks>
        **WARNING: THE HARDWARE TRANSPORT IS EXPERIMENTAL!**

        The HardwareTransport is disabled by default by the node setup classes.
        Use `--robotraconteur-hardware-enable=true` option to enable.

        It is recommended that ClientNodeSetup, ServerNodeSetup, or SecureServerNodeSetup
        be used to construct this class.

        See robotraconteur_url for more information on URLs.

        Contact Wason Technology, LLC for more information on the hardware
        transport.

        The use of RobotRaconteurNodeSetup and subclasses is recommended to construct
        transports.

        The transport must be registered with the node using
        RobotRaconteurNode.RegisterTransport() after construction if node
        setup is not used.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.HardwareTransport.#ctor">
      <summary>
        Construct a new HardwareTransport for use with default node. Must be registered with node
        using
        RobotRaconteurNode.s.RegisterTransport()
      </summary>
    </member>

    <member name="M:RobotRaconteur.HardwareTransport.#ctor(RobotRaconteur.RobotRaconteurNode)">
      <summary>
        Construct a new HardwareTransport for a non-default node. Must be registered with node using
        node.RegisterTransport()
      </summary>
      <param name="node">The node to use with the transport</param>
    </member>

    <member name="M:RobotRaconteur.HardwareTransport.Close">
      <summary>
        Close the transport. Done automatically by node shutdown.
      </summary>
    </member>

    <member name="T:RobotRaconteur.IntraTransport">
      <summary>
        Transport for intra-process communication
</summary>
<remarks>
        It is recommended that ClientNodeSetup, ServerNodeSetup, or SecureServerNodeSetup
        be used to construct this class.

        See robotraconteur_url for more information on URLs.

        The IntraTransport implements transport connections between nodes running
        within the same process. This is often true for simulation environments, where
        there may be multiple simulated devices running within the simulation. The
        IntraTransport uses a singleton to keep track of the different nodes running
        in the same process, and to form connections. The singleton also implements
        discovery updates.

        The use of RobotRaconteurNodeSetup and subclasses is recommended to construct
        transports.

        The transport must be registered with the node using
        RobotRaconteurNode.RegisterTransport() after construction if node
        setup is not used.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.IntraTransport.#ctor">
      <summary>
        Construct a new HardwareTransport for use with default node. Must be registered with node
        using RobotRaconteurNode.s.RegisterTransport()
      </summary>
    </member>

    <member name="M:RobotRaconteur.IntraTransport.#ctor(RobotRaconteur.RobotRaconteurNode)">
      <summary>
        Construct a new IntraTransport for a non-default node. Must be registered with node using
        node.RegisterTransport()
      </summary>
      <param name="node">The node to use with the transport</param>
    </member>

    <member name="M:RobotRaconteur.IntraTransport.Close">
      <summary>
        Close the transport. Done automatically by node shutdown.
      </summary>
    </member>

    <member name="M:RobotRaconteur.IntraTransport.StartServer">
      <summary>
        Start the server to listen for incoming client connections
      </summary>
    </member>

    <member name="T:RobotRaconteur.LocalTransport">
      <summary>
        Transport for communication between processes using UNIX domain sockets
</summary>
<remarks>
        It is recommended that ClientNodeSetup, ServerNodeSetup, or SecureServerNodeSetup
        be used to construct this class.

        See robotraconteur_url for more information on URLs.

        The LocalTransport implements transport connections between processes running on the
        same host operating system using UNIX domain sockets. UNIX domain sockets are similar
        to standard networking sockets, but are used when both peers are on the same machine
        instead of connected through a network. This provides faster operation and greater
        security, since the kernel simply passes data between the processes. UNIX domain
        sockets work using Information Node (inode) files, which are special files on
        the standard filesystem. Servers "listen" on a specified inode, and clients
        use the inode as the address to connect. The LocalTransport uses UNIX sockets
        in `SOCK_STREAM` mode. This provides a reliable stream transport connection similar
        to TCP, but with significantly improved performance due the lower overhead.

        UNIX domain sockets were added to Windows 10 with the 1803 update. Robot Raconteur
        switch to UNIX domain sockets for the LocalTransport on Windows in version 0.9.2.
        Previous versions used Named Pipes, but these were inferior to UNIX sockets. The
        LocalTransport will not function on versions of Windows prior to Windows 10 1803 update
        due to the lack of support for UNIX sockets. A warning will be issued to the log if
        the transport is not available, and all connection attempts will fail. All other
        transports will continue to operate normally.

        The LocalTransport stores inode and node information files in the filesystem at various
        operator system dependent locations. See the Robot Raconteur Standards documents
        for details on where these files are stored.

        Discovery is implemented using file watchers. The file watchens must be activated
        using the node setup flags, or by calling EnableNodeDiscoveryListening().
        After being initialized the file watchers operate automatically.

        The LocalTransport can be used to dynamically assign NodeIDs to nodes based on a NodeName.
        StartServerAsNodeName() and StartClientAsNodeName() take a NodeName that will identify the
        node to clients, and manage a system-local NodeID corresponding to that NodeName. The
        generated NodeIDs are stored on the local filesystem. If LocalTransport finds a
        corresponding
        NodeID on the filesystem, it will load and use that NodeID. If it does not, a new random
        NodeID
        is automatically generated.

        The server can be started in "public" or "private" mode. Private servers store their
        inode and
        information in a location only the account owner can access, while "public" servers are
        placed in a location that all users with the appropriate permissions can access. By default,
        public LocalTransport servers are assigned to the "robotraconteur" group. Clients that
        belong to the
        "robotraconteur" group will be able to connect to these public servers.

        The use of RobotRaconteurNodeSetup and subclasses is recommended to construct
        transports.

        The transport must be registered with the node using
        RobotRaconteurNode.RegisterTransport() after construction if node
        setup is not used.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.LocalTransport.#ctor">
      <summary>
        Construct a new LocalTransport for use with default node. Must be registered with node
        using
        RobotRaconteurNode.s.RegisterTransport()
      </summary>
    </member>

    <member name="M:RobotRaconteur.LocalTransport.#ctor(RobotRaconteur.RobotRaconteurNode)">
      <summary>
        Construct a new LocalTransport for a non-default node. Must be registered with node using
        node.RegisterTransport()
      </summary>
      <param name="node">The node to use with the transport</param>
    </member>

    <member name="M:RobotRaconteur.LocalTransport.Close">
      <summary>
        Close the transport. Done automatically by node shutdown.
      </summary>
    </member>

    <member name="M:RobotRaconteur.LocalTransport.StartClientAsNodeName(System.String)">
      <summary>
        Initialize the LocalTransport by assigning a NodeID based on NodeName
</summary>
<remarks>
        Assigns the specified name to be the NodeName of the node, and manages
        a corresponding NodeID. See LocalTransport for more information.

        Throws NodeNameAlreadyInUse if another node is using name
      </remarks>
      <param name="name">The node name</param>
    </member>

    <member name="M:RobotRaconteur.LocalTransport.StartServerAsNodeName(System.String)">
      <summary>
        Start the server using the specified NodeName and assigns a NodeID
</summary>
<remarks>
        The LocalTransport will listen on a UNIX domain socket for incoming clients,
        using information files and inodes on the local filesystem. Clients
        can locate the node using the NodeID and/or NodeName. The NodeName is assigned
        to the node, and the transport manages a corresponding NodeID. See
        LocalTransport for more information.

        Throws NodeNameAlreadyInUse if another node is using name.

        Throws NodeIDAlreadyInUse if another node is using the managed NodeID.
      </remarks>
      <param name="name">The NodeName</param>
    </member>

    <member
      name="M:RobotRaconteur.LocalTransport.StartServerAsNodeName(System.String,System.Boolean)">
      <summary>
        Start the server using the specified NodeName and assigns a NodeID
</summary>
<remarks>
        The LocalTransport will listen on a UNIX domain socket for incoming clients,
        using information files and inodes on the local filesystem. Clients
        can locate the node using the NodeID and/or NodeName. The NodeName is assigned
        to the node, and the transport manages a corresponding NodeID. See
        LocalTransport for more information.

        Throws NodeNameAlreadyInUse if another node is using name.

        Throws NodeIDAlreadyInUse if another node is using the managed NodeID.
      </remarks>
      <param name="name">The NodeName</param>
      <param name="public_">If True, other users can access the server. If False, only
        the account owner can access the server.</param>
    </member>

    <member name="M:RobotRaconteur.LocalTransport.StartServerAsNodeID(RobotRaconteur.NodeID)">
      <summary>
        The LocalTransport will listen on a UNIX domain socket for incoming clients,
        using information files and inodes on the local filesystem. This function
        leaves the NodeName blank, so clients must use NodeID to identify the node.

        Throws NodeIDAlreadyInUse if another node is using nodeid.
      </summary>
      <param name="name">The NodeName</param>
    </member>

    <member
      name="M:RobotRaconteur.LocalTransport.StartServerAsNodeID(RobotRaconteur.NodeID,System.Boolean)">
      <summary>
        The LocalTransport will listen on a UNIX domain socket for incoming clients,
        using information files and inodes on the local filesystem. This function
        leaves the NodeName blank, so clients must use NodeID to identify the node.

        Throws NodeIDAlreadyInUse if another node is using nodeid
      </summary>
      <param name="name">The NodeName</param>
      <param name="public_">If True, other users can access the server. If False, only
        the account owner can access the server.</param>
    </member>

    <member name="T:RobotRaconteur.TcpTransport">
      <summary>
        Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks
</summary>
<remarks>
        It is recommended that ClientNodeSetup, ServerNodeSetup, or SecureServerNodeSetup
        be used to construct this class.

        See robotraconteur_url for more information on URLs.

        The TcpTransport implements transport connections over TCP/IP networks. TCP/IP is the
        most common protocol used for Internet and Local Area Network (LAN) communication, including
        Ethernet and WiFi connections. The Transport Control Protocol (TCP) is a reliable stream
        protocol that establishes connections between devices using IP address and port pairs.
        Each adapter has an assigned address, and applications create connections on different
        ports.
        TcpTransport listens to the port specified in StartServer(), and the client uses
        a URL containing the IP address and port of the listening transport. The TcpTransport
        uses the established connection to pass messages between nodes.

        The IP protocol is available in two major versions, IPv4 and IPv6. The most common
        is IPv4, and its 32 bit address is typically written as four numbers,
        ie 172.17.12.174. IPv4 has a number of critical limitations, the greatest being
        its 2^32 address limit (approximately 4 billion). This is a problem when there are
        tens of billions of internet connected devices already present. IPv6 introduces a 128
        bit address space, which allows for approximately 3.4x10^38 possible addresses. The major
        advantage for Robot Raconteur is the introduction of "link-local" addresses. These
        addresses
        begin with "FE80::" and finish with an "EUI-64" address, which is tied to the MAC
        address
        of the adaptor. IPv4 addresses need to be assigned to devices locally, and have a tendency
        to change. IPv6 addresses are permanently assigned to the adapter itself, meaning that
        network configuration for LAN communication is essentially automatic. Robot Raconteur
        will prefer IPv6 connections when possible for this reason.

        The TcpTransport is capable of using "raw" streams that implement the Robot Raconteur
        message protocols, or to use HTTP WebSockets. HTTP WebSockets allow Robot Raconteur
        to communicate seamlessly with browsers and HTTP servers without requiring
        additional plugins. WebSockets provide additional security using "origins". See
        AddWebSocketAllowedOrigin() for more information.

        The TcpTransport supports TLS encryption using certificates. See \\ref tls_security for
        more information on TLS. The TcpTransport supports four modes of TLS encryption:

        <list type="table">
          <listheader>
          <term>Scheme</term>
          <term>Description</term>
          <term>Direction</term>
          </listheader>
          <item>
          <term>rrs+tcp</term>
          <term>"Raw" protocol with TLS</term>
          <term>Both</term>
          </item>
          <item>
          <term>rr+wss</term>
          <term>Websocket over HTTPS</term>
          <term>Client Only</term>
          </item>
          <item>
          <term>rrs+ws</term>
          <term>Websocket with RobotRaconteur TLS over HTTP</term>
          <term>Both</term>
          </item>
          <item>
          <term>rrs+wss</term>
          <term>Websocket with RobotRaconteur TLS over HTTPS</term>
          <term>Client Only</term>
          </item>
          </list>

        The different combinations of TLS and HTTPS for websockets are used for different scenarios.
        Robot Raconteur Core can initiate HTTPS connections, but cannot accept them. Accepting
        HTTPS connections requires a certificate issued by an authority like GoDaddy or Digicert,
        and is typically used with an HTTP server running RobotRaconteurWeb.

        TLS certificates for Robot Raconteur nodes are issued by Wason Technology, LLC using
        a root certificate that is "burned in" to Robot Raconteur Core. All devices running
        Robot Raconteur will support this certificate chain.

        Discovery for the TcpTransport is accomplished using User Defined Protocol (UDP) multicast
        and/or broadcast packets. Broadcast packets are sent to all connected devices, while
        multicast is sent to devices that have registered to receive them. Unlike TCP, the packets
        sent to broadcast or multicast are sent to the entire network. This allows for devices
        to find each other on the network.

        For IPv4, the broadcast address 255.255.255.255 on port 48653
        is used for discovery. By default, IPv4 is disabled in favor of IPv6. IPv6 uses the
        multicast
        following multicast addresses:

        <list type="table">
          <listheader>
          <term>Address</term>
          <term>Scope</term>
          <term>Port</term>
          <term>Default?</term>
          </listheader>
          <item>
          <term>FF01::BA86</term>
          <term>Node-Local</term>
          <term>48653</term>
          <term>Disabled</term>
          </item>
          <item>
          <term>FF02::BA86</term>
          <term>Link-Local</term>
          <term>48653</term>
          <term>Enabled</term>
          </item>
          <item>
          <term>FF05::BA86</term>
          <term>Site-Local</term>
          <term>48653</term>
          <term>Disabled</term>
          </item>
          </list>

        By default, discovery will only occur on the link-local IPv6 scope. This will
        find nodes on the local subnet, but will not attempt to pass through any routers.

        The use of RobotRaconteurNodeSetup and subclasses is recommended to construct
        transports.

        The transport must be registered with the node using
        RobotRaconteurNode.RegisterTransport() after construction if node
        setup is not used.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.TcpTransport.#ctor">
      <summary>
        Construct a new TcpTransport for use with default node. Must be registered with node
        using
        RobotRaconteurNode.s.RegisterTransport()
      </summary>
    </member>

    <member name="M:RobotRaconteur.TcpTransport.#ctor(RobotRaconteur.RobotRaconteurNode)">
      <summary>
        Construct a new LocalTransport for a non-default node. Must be registered with node using
        node.RegisterTransport()
      </summary>
      <param name="node">The node to use with the transport</param>
    </member>

    <member name="M:RobotRaconteur.TcpTransport.Close">
      <summary>
        Close the transport. Done automatically by node shutdown.
      </summary>
    </member>

    <member
      name="M:RobotRaconteur.TcpTransport.EnableNodeDiscoveryListening(RobotRaconteur.IPNodeDiscoveryFlags)">
      <summary>
        Enable node discovery listening
</summary>
<remarks>
        By default enables listining on IPv6 link-local scope

        See IPNodeDiscoveryFlags constants
      </remarks>
      <param name="flags">The flags specifying the scope</param>
    </member>

    <member name="M:RobotRaconteur.TcpTransport.EnableNodeDiscoveryListening">
      <summary>
        Enable node discovery listening
</summary>
<remarks>
        By default enables listining on IPv6 link-local scope

        See IPNodeDiscoveryFlags constants
      </remarks>
    </member>

    <member name="M:RobotRaconteur.TcpTransport.DisableNodeDiscoveryListening">
      <summary>
        Disable node discovery listening
      </summary>
    </member>

    <member
      name="M:RobotRaconteur.TcpTransport.EnableNodeAnnounce(RobotRaconteur.IPNodeDiscoveryFlags)">
      <summary>
        Enable node discovery announce
</summary>
<remarks>
        By default enables announce on IPv6 link-local scope

        See IPNodeDiscoveryFlags constants
      </remarks>
      <param name="flags">The flags specifying the scope</param>
    </member>

    <member name="M:RobotRaconteur.TcpTransport.EnableNodeAnnounce">
      <summary>
        Enable node discovery announce
</summary>
<remarks>
        By default enables announce on IPv6 link-local scope

        See IPNodeDiscoveryFlags constants
      </remarks>
    </member>

    <member name="M:RobotRaconteur.TcpTransport.DisableNodeAnnounce">
      <summary>
        Disable node discovery announce
      </summary>
    </member>

    <member name="T:RobotRaconteur.TimerEvent">
      <summary>
        Timer event structure
</summary>
<remarks>
        Contains information about the state of the timer. Passed to the
        callback on invocation.
      </remarks>
    </member>

    <member name="P:RobotRaconteur.TimerEvent.stopped">
      <summary>
        True if timer has been stopped
      </summary>
    </member>

    <member name="P:RobotRaconteur.TimerEvent.last_expected">
      <summary>
        The last expected callback invocation time
      </summary>
    </member>

    <member name="P:RobotRaconteur.TimerEvent.last_real">
      <summary>
        The last real callback invocation time
      </summary>
    </member>

    <member name="P:RobotRaconteur.TimerEvent.current_expected">
      <summary>
        The current expected callback invocation time
      </summary>
    </member>

    <member name="P:RobotRaconteur.TimerEvent.current_real">
      <summary>
        The current real callback invocation time
      </summary>
    </member>

    <member name="T:RobotRaconteur.Timer">
      <summary>
        A timer to invoke a callback
</summary>
<remarks>
        Timers invoke a callback at a specified rate. The timer
        can either be one-short, or repeating.

        Use RobotRaconteurNode.CreateTimer() to create timers.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.Timer.Start">
      <summary>
        Start the timer
</summary>
<remarks>
        Must be called after RobotRaconteurNode.CreateTimer()
      </remarks>
    </member>

    <member name="M:RobotRaconteur.Timer.Stop">
      <summary>
        Stop the timer
      </summary>
    </member>

    <member name="M:RobotRaconteur.Timer.GetPeriod">
      <summary>
        Get the period of the timer in milliseconds
      </summary>
    </member>

    <member name="M:RobotRaconteur.Timer.SetPeriod(System.Int32)">
      <summary>
        Set the period of the timer in milliseconds
      </summary>
      <param name="period">Period in milliseconds</param>
    </member>

    <member name="M:RobotRaconteur.Timer.IsRunning">
      <summary>
        Get if the timer is running
      </summary>
    </member>

    <member name="T:RobotRaconteur.Rate">
      <summary>
        Rate to stabilize a loop
</summary>
<remarks>
        Rate is used to stabilize the period of a loop. Use
        RobotRaconteur.CreateRate() to create rates.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.Rate.Sleep">
      <summary>
        Sleep the calling thread until the current loop period expires
      </summary>
    </member>

    <member name="T:RobotRaconteur.AutoResetEvent">
      <summary>
        Synchronization event for thread synchronization. Resets automatically after
        being triggered

        Construct using RobotRaconteurNode.CreateAutoResetEvent()
      </summary>
    </member>

    <member name="M:RobotRaconteur.AutoResetEvent.Set">
      <summary>
        Set the event, releasing waiting threads
      </summary>
    </member>

    <member name="M:RobotRaconteur.AutoResetEvent.Reset">
      <summary>
        Reset the event
      </summary>
    </member>

    <member name="M:RobotRaconteur.AutoResetEvent.WaitOne">
      <summary>
        Block the current thread until Set() is called
      </summary>
    </member>

    <member name="M:RobotRaconteur.AutoResetEvent.WaitOne(System.Int32)">
      <summary>
        Block the current thread until Set() is called, or timeout
        expires

        Timeout is based on the RobotRaconteurNode time provider
      </summary>
      <param name="timeout">The timeout in milliseconds</param>
      <returns>true if event was set, otherwise false</returns>
    </member>

    <member name="T:RobotRaconteur.NodeID">
      <summary>
        NodeID UUID storage and generation
</summary>
<remarks>
        Robot Raconteur uses NodeID and NodeName to uniquely identify a node.
        NodeID is a UUID (Universally Unique ID), while NodeName is a string. The
        NodeID is expected to be unique, while the NodeName is set by the user
        and may not be unique. The NodeID class represents the UUID NodeID.

        A UUID is a 128-bit randomly generated number that is statistically guaranteed
        to be unique to a very high probability. NodeID uses the Boost.UUID library
        to generate, manage, and store the UUID.

        The UUID can be loaded from a string, bytes, or generated randomly at runtime.
        It can be converted to a string.

        The LocalTransport and ServerNodeSetup classes will automatically assign
        a NodeID to a node when the local transport is started with a specified node name.
        The generated NodeID is stored on the local system, and is associated with the node name.
        It will be loaded when a node is started with the same NodeName.

        NodeID with all zeros is considered "any" node.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.NodeID.#ctor">
      <summary>
        Construct a new NodeID with "any" node UUID
      </summary>
    </member>

    <member name="M:RobotRaconteur.NodeID.#ctor(System.Byte[])">
      <summary>
        Construct a new NodeID with the specified UUID bytes
      </summary>
      <param name="id">The UUID bytes</param>
    </member>
    <member name="M:RobotRaconteur.NodeID.#ctor(System.String)">
      <summary>
        Construct a new NodeID parsing a string UUID
      </summary>
      <param name="id">The UUID as a string</param>
    </member>

    <member name="M:RobotRaconteur.NodeID.ToString">
      <summary> Convert the NodeID UUID to string with "B" format<br /> Convert the UUID string to
        8-4-4-4-12 "B" format (with brackets)<br /> {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} </summary>
    </member>

    <member name="M:RobotRaconteur.NodeID.IsAnyNode">
      <summary>
        Is the NodeID UUID all zeros
</summary>
<remarks>
        The all zero UUID respresents "any" node, or an unset NodeID
      </remarks>
      <returns>true The NodeID UUID is all zeros, representing any node, false The NodeID UUID is
        not all zeros</returns>
    </member>

    <member name="M:RobotRaconteur.NodeID.GetAny">
      <summary>
        Get the "any" NodeId
      </summary>
      <returns>The "any" NodeID</returns>
    </member>

    <member name="M:RobotRaconteur.NodeID.ToByteArray">
      <summary>
        Convert the NodeID UUID to bytes
      </summary>
      <returns>The UUID as bytes</returns>
    </member>

    <member name="M:RobotRaconteur.NodeID.NewUniqueID">
      <summary>
        Generate a new random NodeID UUID
</summary>
<remarks>
        Returned UUID is statistically guaranteed to be unique
      </remarks>
      <returns>The newly generated UUID</returns>
    </member>

    <member name="T:RobotRaconteur.ServerContext">
      <summary>
        Context for services registered in a node for use by clients
</summary>
<remarks>
        Services are registered using the RobotRaconteurNode.RegisterService() family of functions.
        The ServerContext manages the services, and dispatches requests and packets to the
        appropriate
        service object members. Services may expose more than one object. The root object is
        specified
        when the service is registered. Other objects are specified through ObjRef members. A name
        for the service is also specified when the service is registered. This name forms the root
        of the service path namespace. Other objects in the service have a unique service path
        based on the ObjRef used to access the object.

        Services may handle multiple connected clients concurrently. Each client is assigned
        a ServerEndpoint. The ServerEndpoint is unique to the client connection,
        and interacts with ServerContext to complete requests and dispatch packets. When
        the service needs to address a specific client, the ServerEndpoint or the
        ServerEndpoint.GetCurrentEndpoint() is used. (ServerEndpoint.GetCurrentEndpoint() returns
        the
        int local client ID.)

        Service attributes are a varvalue{string} types dictionary that is made available to
        clients during service discovery. These attributes are used to help clients determine
        which service should be selected for use. Because the attributes are passed to the clients
        as part of the discovery process, they should be as concise as possible, and should
        not use user defined types. Use ServerContext.SetAttributes() to set the service attributes
        after registering the service.

        Security for the service is specified using a ServiceSecurityPolicy instance. This policy
        is specified by passing as a parameter to RobotRaconteurNode.RegisterService(), or passing
        the policy to the constructor.

        ServerContext implements authentication and object locking.
        Server side functions are exposed by ServerContext for authentication, object locking,
        and client management.

        Clients using dynamic typing such as Python and MATLAB will only pull service types
        explicitly imported by the root object and objref objects that have been requested. Clients
        will not pull service types of user-defined named types if that service type is not
        explicitly
        imported. This can be problematic if new `struct`, `pod`, and/or `namedarray` types are
        introduced
        that do not have corresponding objects. Extra imports is used to specify extra service
        definitions
        the client should pull. Use ServerContext.AddExtraImport(),
        ServerContext.RemoveExtraImport(),
        and ServerContext.GetExtraImports() to manage the extra imports passed to the client.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.ServerContext.GetCurrentServicePath">
      <summary>
        Get the current object service path
</summary>
<remarks>
        Returns the service path of the current object during a request or
        packet event.
        This is a thread-specific value and only
        valid during the initial request or packet event invocation.
      </remarks>
      <returns>The current object service path</returns>
    </member>

    <member name="P:RobotRaconteur.ServerContext.CurrentServicePath">
      <summary>
        Get the current object service path
</summary>
<remarks>
        Returns the service path of the current object during a request or
        packet event.
        This is a thread-specific value and only
        valid during the initial request or packet event invocation.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.ServerContext.GetCurrentServerContext">
      <summary>
        Get the current ServerContext
</summary>
<remarks>
        Returns the current server context during a request or packet event.
        This is a thread-specific value and only
        valid during the initial request or packet event invocation.
      </remarks>
      <return>The current server context</return>
    </member>

    <member name="P:RobotRaconteur.ServerContext.CurrentServerContext">
      <summary>
        Get the current ServerContext
</summary>
<remarks>
        Returns the current server context during a request or packet event.
        This is a thread-specific value and only
        valid during the initial request or packet event invocation.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.ServerContext.KickUser(System.String)">
      <summary>
        Kicks a user with the specified username
</summary>
<remarks>
        User must be authenticated.
      </remarks>
      <param name="username">The username to kick</param>
    </member>

    <member name="M:RobotRaconteur.ServerContext.RequestObjectLock(System.String,System.String)">
      <summary>
        Request an object lock on servicepath for user username
</summary>
<remarks>
        This function handles incoming client requests, but may also be used
        by the service directly
      </remarks>
      <param name="servicepath">The service path to lock</param>
      <param name="username">The name of the user owning the lock</param>
    </member>

    <member name="M:RobotRaconteur.ServerContext.RequestClientObjectLock(System.String,System.String,System.UInt32)">
      <summary>
        Request a client lock on servicepath for a specific client connection
</summary>
<remarks>
        This function handles incoming client requests, but may also be used
        by the service directly. Client object locks lock for a specific client connection,
        while client locks lock for a specific user. The specific client connection is
        specified using endpoint.
      </remarks>
      <param name="servicepath">The service path to lock</param>
      <param name="username">The name of the user owning the lock</param>
      <param name="endpoint">The client endpoint ID of the client owning the lock</param>
    </member>

    <member
      name="M:RobotRaconteur.ServerContext.ReleaseObjectLock(System.String,System.String,System.Boolean)">
      <summary>
        Release a client lock on servicepath
</summary>
<remarks>
        This function handles incoming client requests, but may also be used
        by the service directly. Client locks can be released by the user that
        created them if override_ is false, or by any user if override_ is true.

        The override_ parameter is set to true for client requests if the client has
        the \"objectlockoverride\" permission.
      </remarks>
      <param name="servicepath">The service path to release lock</param>
      <param name="username">The username requsting the lock release</param>
      <param name="override_">If False, only the creating username can release the lock. If True,
        any username can release the lock</param>
    </member>

    <member name="M:RobotRaconteur.ServerContext.GetObjectLockUsername(System.String)">
      <summary>
        Get the name of the user that has locked the specified service path
      </summary>
      <param name="servicepath">The service path</param>
      <returns>The user owning the lock, or empty servicepath is not locked</returns>
    </member>

    <member name="M:RobotRaconteur.ServerContext.GetExtraImports">
      <summary>
        Get the current list of extra service definition imports
      </summary>
      <returns>The list of extra imports</returns>
    </member>

    <member name="M:RobotRaconteur.ServerContext.AddExtraImport(System.String)">
      <summary>
        Add an extra service definition import
</summary>
<remarks>
        Clients using dynamic typing will not automatically pull service definitions unless
        imported by the root object or an objref. If new \"struct\", \"po\", or \"namedarray\" types
        are introduced in a new service definition type without a corresponding object, an error
        will
        occur. Use AddExtraImport() to add the name of the new service definition to add it to the
        list of service definitions the client will pull.

        Service definition must have been registered using RobotRaconteurNode.RegisterServiceType()
      </remarks>
      <param name="import_">The name of the service definition</param>
    </member>

    <member name="M:RobotRaconteur.ServerContext.RemoveExtraImport(System.String)">
      <summary>
        Removes an extra import service definition registered with AddExtraImport()
</summary>
<remarks>
        See AddExtraImport()
      </remarks>
      <param name="import_">The name of the service definition</param>
      <returns>true The service definition was removed, false The service definition was not found
        in the extra imports vector</returns>
    </member>


    <member name="M:RobotRaconteur.ServerContext.SetServiceAttributes(System.Collections.Generic.Dictionary{System.String,System.Object})">
      <summary>
        Set the service attributes
</summary>
<remarks>
        Sets the service attributes. Attributes are made available to clients during
        service discovery. Attributes should be concise and not use any user defined
        types.
      </remarks>
      <param name="attributes">The service attributes</param>
    </member>
    <member name="M:RobotRaconteur.ServerContext.AddServerServiceListener(RobotRaconteur.ServerContext.ServerServiceListenerDelegate)">
      <summary>
        Add a service listener
      </summary>
      <param name="listener">Callable listener function</param>
    </member>
    <member name="M:RobotRaconteur.ServerContext.ReleaseServicePath(System.String)">
      <summary> Release the specified service path and all sub objects Services take ownership of
        objects returned by objrefs, and will only request the object once. Subsequent requests will
        return the cached object. If the objref has changed, the service must call
        ReleaseServicePath() to tell the service to request the object again. Release service path
        will release the object specified by the service path and all sub objects. This overload
        will notify all clients that the objref has been released. If the service path contains a
        session key, use ReleaseServicePath(string, uint[]) to only
        notify the client that owns the session.
      </summary>
      <param name="path">The service path to release</param>
    </member>
    <member name="M:RobotRaconteur.ServerContext.ReleaseServicePath(System.String,System.UInt32[])">
      <summary>
        Release the specified service path and all sub objects
</summary>
<remarks>
        Services take ownership of objects returned by objrefs, and will only request the object
        once. Subsequent requests will return the cached object. If the objref has changed,
        the service must call ReleaseServicePath() to tell the service to request the object again.
        Release service path will release the object specified by the service path
        and all sub objects.

        This overload will notify the specified that the objref has been released. If the service
        path contains a session key, this overload should be used so the session key is not leaked.
      </remarks>
      <param name="path">The service path to release</param>
      <param name="endpoints">The client endpoint IDs to notify of the released service path</param>
    </member>

    <member name="T:RobotRaconteur.ServerEndpoint">
      <summary>
        Server endpoint representing a client connection
</summary>
<remarks>
Robot Raconteur creates endpoint pairs between a client and service. For clients, this endpoint
is a ClientContext. For services, the endpoint becomes a ServerEndpoint. ServerEndpoints are used
to address a specific client connected to a service, since services may have multiple clients
connected concurrently. ServerEndpoints also provide client authentication information.

Use ServerEndpoint.GetCurrentEndpoint() to retrieve the int32
current endpoint ID. Use ServerEndpoint.GetCurrentAuthenticatedUser() to retrieve
the current user authentication information.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.ServerEndpoint.GetCurrentEndpoint">
      <summary>
        Returns the current server endpoint
</summary>
<remarks>
Returns the current server endpoint during a request or packet event.
This is a thread-specific value and only valid during the initial
request or packet event invocation.

Throws InvalidOperationException if not during a request or packet event
      </remarks>
      <returns>The current server endpoint id</returns>
    </member>

    <member name="M:RobotRaconteur.ServerEndpoint.GetCurrentAuthenticatedUser">
      <summary>
        Returns the current authenticated user
</summary>
<remarks>
Users that have been authenticated have a corresponding
AuthenticatedUser object associated with the ServerEndpoint.
GetCurrentAuthenticatedUser() returns the AuthenticatedUser
associated with the current ServerEndpoint during a request
or packet event. This is a thread-specific value and only valid during 
the initial request or packet event invocation.

Throws PermissionDeniedException or AuthenticationException
if there is no AuthenticatedUser set in the current thread. 
      </remarks>

    </member>

    <member name="T:RobotRaconteur.AuthenticatedUser">
      <summary>
        Class representing an authenticated user
</summary>
<remarks>
Use ServerEndpoint.GetCurrentAuthenticatedUser() to retrieve the
authenticated user making a request

See \\ref security for more information.
      </remarks>
    </member>

    <member name="T:RobotRaconteur.ServiceSecurityPolicy">
      <summary>
        Security policy for Robot Raconteur service
      </summary>
      <remarks>
        The security policy sets an authenticator, and a set of policies. PasswordFileUserAuthenticator is
an example of an authenticator. The valid options for Policies are as follows:

<list type="table">
  <listheader>
  <term>Policy name</term>
  <term>Possible Values</term>
  <term>Default</term>
  <term>Description</term>
  </listheader>
  <item>
  <term>requirevaliduser</term>
  <term>true,false</term>
  <term>false</term>
  <term>Set to "true" to require a user be authenticated before accessing
  service</term>
  </item>
  <item>
  <term>allowobjectlock</term>
  <term>true,false</term>
  <term>false</term>
  <term>If "true" allow users to request object locks. requirevaliduser must
  also be "true"</term>
  </item>
  </list>

The security policy is passed as a parameter to RobotRaconteurNode.RegisterService().

See security for more information.
      </remarks>
    </member>

    <member name="M:RobotRaconteur.ServiceSecurityPolicy.#ctor(RobotRaconteur.IUserAuthenticator,System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>Construct a new security policy</summary>
      <param name="authenticator">The user authenticator</param>
      <param name="policies">The security policies</param>
    </member>

    <member name="T:RobotRaconteur.NativeUserAuthenticator">
      <summary>
        Base class for user authenticators
</summary>
<remarks>
        Used with ServiceSecurityPolicy to secure services

        Override AuthenticateUser to implement different types
        of user authenticators.
      </remarks>
    </member>

    <member name="T:RobotRaconteur.PasswordFileUserAuthenticator">
      <summary>
        Simple authenticator using a list of username, password hash, and privileges stored in a
        file or string

        The password user authenticator expects a string containing a list of users,
        one per line. Each line contains the username, password as md5 hash, and privileges,
        separated by white spaces.
        An example of authentication string contents:

        <code>
        user1 79e262a81dd19d40ae008f74eb59edce objectlock
        user2 309825a0951b3cf1f25e27b61cee8243 objectlock
        superuser1 11e5dfc68422e697563a4253ba360615 objectlock,objectlockoverride
        </code>


        The password is md5 hashed. This hash can be generated using the ``--md5passwordhash``
        command in the \"RobotRaconteurGen\" utility.
        The privileges are comma separated. Valid privileges are as follows:

        <list type="table">
          <listheader>
          <term>Policy name</term>
          <term>Possible Values</term>
          <term>Default</term>
          <term>Description</term>
          </listheader>
          <item>
          <term>requirevaliduser</term>
          <term>true,false</term>
          <term>false</term>
          <term>Set to "true" to require a user be authenticated before accessing
          service</term>
          </item>
          <item>
          <term>allowobjectlock</term>
          <term>true,false</term>
          <term>false</term>
          <term>If "true" allow users to request object locks. requirevaliduser must
          also be "true"</term>
          </item>
          </list>
      </summary>
    </member>

    <member name="M:RobotRaconteur.PasswordFileUserAuthenticator.#ctor(System.String)">
      <summary>
        Construct a new PasswordFileUserAuthenticator
      </summary>
      <summary name="data">The file text</summary>
    </member>

    <member name="M:RobotRaconteur.PasswordFileUserAuthenticator.#ctor(System.String,System.Boolean)">
      <summary>
        Construct a new PasswordFileUserAuthenticator
      </summary>
      <summary name="data">The file text</summary>
      <summary name="require_verified_client">Require clients to be verified</summary>
    </member>

    <member name="T:RobotRaconteur.RRLogRecord">
      <summary>
        Robot Raconteur log record
</summary>
<remarks>
        Records information about a logging event

        See \\ref logging for more information.
      </remarks>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.Level">
      <summary>
        The log level
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.Component">
      <summary>
        The source component
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.ComponentName">
      <summary>
        The source component name
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.ComponentObjectID">
      <summary>
        The source component object ID
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.Endpoint">
      <summary>
        The source endpoint
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.ServicePath">
      <summary>
        The service path of the source object
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.Member">
      <summary>
        The source member
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.Message">
      <summary>
        Human readable log message
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.Time">
      <summary>
        Time of logging event
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.SourceFile">
      <summary>
        The sourcecode filename
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.SourceLine">
      <summary>
        The line within the sourcecode file
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.ThreadID">
      <summary>
        The source thread
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.FiberID">
      <summary>
        The source coroutine fiber
      </summary>
    </member>

    <member name="P:RobotRaconteur.RRLogRecord.Node">
      <summary>
        The source node
      </summary>
    </member>

    <member name="T:RobotRaconteur.LogRecordHandler">
      <summary>
        Base class of log record handler
</summary>
<remarks>
By default, RobotRaconteurNode will print log records to ``stderr``. Use
RobotRaconteur.RobotRaconteurNode.SetLogRecordHandler() to specify a LogRecordHandler
to accept log records instead of printing them to the terminal.

See \\ref logging for more information.
      </remarks>
    </member>

    <member name="T:RobotRaconteur.FileLogRecordHandler">
      <summary>
        Log record handler that saves to a file
</summary>
<remarks>
See \\ref logging for more information.
      </remarks>
    </member>

    <member name="T:RobotRaconteur.FileLogRecordHandler.#ctor">
      <summary>
        Construct a FileLogRecordHandler. Use OpenFile() to open a file.
      </summary>
    </member>

    <member name="M:RobotRaconteur.FileLogRecordHandler.OpenFile(System.String)">
      <summary>
        Open a file to store log records
      </summary>
      <param name="filename">The filename</param>
    </member>

    <member name="M:RobotRaconteur.FileLogRecordHandler.OpenFile(System.String,System.Boolean)">
      <summary>
        Open a file to store log records
      </summary>
      <param name="filename">The filename</param>
      <param name="append">If true, log messages are appended. If false, the file is truncated when opened</param>
    </member>

    <member name="T:RobotRaconteur.BroadcastDownsampler">
      <summary>
      Downsampler to manage rate of packets sent to client
</summary>
<remarks>
PipeBroadcaster and WireBroadcaster by default sends packets to all clients when
a pipe packet is sent or the wire value is changed. The updates typically happen
within a sensor or control loop, with the rate set by the specific device producing
the updates. Some clients may require less frequent data, and may run in to bandwidth
or processing issues if the data is sent at the full update rate. The BroadcastDownsampler
is used to implement broadcaster predicates that will drop packets. 
Clients specify how many packets they want dropped between each packet sent. For instance,
a downsample of 0 means that no packets are dropped. A downsample of 1 will drop every other
packet. A downsample of two will drop 2 packets between sending 1 packet, etc. The 
downsample level for each client is set using SetClientDownsample(). This should be
made available to the client using a property member.

PipeBroadcaster and WireBroadcaster must be added to the downsampler
using AddPipeBroadcaster() and AddWireBroadcaster(), respectively.
It is recommended that these functions be called within
the RRServiceObjectInit(context,servicepath) function thit is called
by the node when a service object is initialized.

BeginStep() and EndStep() must be called for each iteration of the
broadcasting loop. Use BroadcastDownsamplerStep for automatic
management in the loop.

See com.robotraconteur.isoch.IsochDevice for the standard use 
of downsampling. 
</remarks>
    </member>

    <member name="M:RobotRaconteur.BroadcastDownsampler.#ctor(RobotRaconteur.ServerContext,System.UInt32)">
      <summary>
        Construct a new BroadcastDownsampler
      </summary>
      <param name="context">The service context</param>
      <param name="default_downsample">The default downsample. Usually set to 0</param>
    </member>

    <member name="M:RobotRaconteur.BroadcastDownsampler.GetClientDownsample(System.UInt32)">
      <summary>
        Get the downsample for the specified client
      </summary>
      <param name="ep">The endpoint ID of the client</param>
      <returns>The downsample</returns>
    </member>

    <member name="M:RobotRaconteur.BroadcastDownsampler.SetClientDownsample(System.UInt32,System.UInt32)">
      <summary>
        Set the downsample for the specified client
      </summary>
      <param name="ep">The endpoint ID of the client</param>
      <param name="downsample">The desired downsample</param>
    </member>

    <member name="M:RobotRaconteur.BroadcastDownsampler.BeginStep">
      <summary>
        Begin the update loop step
</summary>
<remarks>
Use BroadcastDownsamplerStep for automatic stepping
      </remarks>
    </member>

    <member name="M:RobotRaconteur.BroadcastDownsampler.EndStep">
      <summary>
        End the update loop step
</summary>
<remarks>
Use BroadcastDownsamplerStep for automatic stepping
      </remarks>
    </member>

  </members>

</doc>